
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tuanle96/agentos-ecosystem/core/api/config/config.go (100.0%)</option>
				
				<option value="file1">github.com/tuanle96/agentos-ecosystem/core/api/handlers/agent_factory.go (29.3%)</option>
				
				<option value="file2">github.com/tuanle96/agentos-ecosystem/core/api/handlers/agents.go (50.0%)</option>
				
				<option value="file3">github.com/tuanle96/agentos-ecosystem/core/api/handlers/auth.go (65.1%)</option>
				
				<option value="file4">github.com/tuanle96/agentos-ecosystem/core/api/handlers/executions.go (26.1%)</option>
				
				<option value="file5">github.com/tuanle96/agentos-ecosystem/core/api/handlers/handlers.go (100.0%)</option>
				
				<option value="file6">github.com/tuanle96/agentos-ecosystem/core/api/handlers/logic_helpers.go (93.5%)</option>
				
				<option value="file7">github.com/tuanle96/agentos-ecosystem/core/api/handlers/memory.go (0.0%)</option>
				
				<option value="file8">github.com/tuanle96/agentos-ecosystem/core/api/handlers/tool_execution.go (0.0%)</option>
				
				<option value="file9">github.com/tuanle96/agentos-ecosystem/core/api/handlers/tools.go (81.8%)</option>
				
				<option value="file10">github.com/tuanle96/agentos-ecosystem/core/api/middleware/auth.go (77.1%)</option>
				
				<option value="file11">github.com/tuanle96/agentos-ecosystem/core/api/models/models.go (55.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "os"
        "strconv"
)

// Config holds all configuration for the API service
type Config struct {
        Environment   string
        Port          string
        DatabaseURL   string
        RedisURL      string
        NatsURL       string
        JWTSecret     string
        OpenAIAPIKey  string
        RateLimit     int
}

// Load loads configuration from environment variables
func Load() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Environment:   getEnv("GO_ENV", "development"),
                Port:          getEnv("CORE_API_PORT", "8000"),
                DatabaseURL:   getEnv("DATABASE_URL", "postgres://agentos:agentos_dev_password@localhost:5432/agentos_dev?sslmode=disable"),
                RedisURL:      getEnv("REDIS_URL", "localhost:6379"),
                NatsURL:       getEnv("NATS_URL", "nats://localhost:4222"),
                JWTSecret:     getEnv("JWT_SECRET", "dev-jwt-secret-change-in-production"),
                OpenAIAPIKey:  getEnv("OPENAI_API_KEY", ""),
                RateLimit:     getEnvAsInt("API_RATE_LIMIT", 10000),
        }
}</span>

// getEnv gets an environment variable with a fallback value
func getEnv(key, fallback string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return fallback</span>
}

// getEnvAsInt gets an environment variable as integer with a fallback value
func getEnvAsInt(key string, fallback int) int <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                        return intValue
                }</span>
        }
        <span class="cov8" title="1">return fallback</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "fmt"
        "strings"
)

// CapabilityConflict represents a conflict between capabilities
type CapabilityConflict struct {
        Capability1  string
        Capability2  string
        Reason       string
        ConflictType string
        Severity     string
}

// CapabilityMetadata contains metadata about each capability
type CapabilityMetadata struct {
        Name         string
        Category     string
        Dependencies []string
        Conflicts    []string
        Description  string
        ResourceCost int
}

// Agent Factory Enhancement - Week 2 Implementation
var capabilityRegistry = map[string]CapabilityMetadata{
        "web_search": {
                Name:         "web_search",
                Category:     "search",
                Dependencies: []string{},
                Conflicts:    []string{},
                Description:  "DuckDuckGo search integration",
                ResourceCost: 2,
        },
        "file_operations": {
                Name:         "file_operations",
                Category:     "file",
                Dependencies: []string{},
                Conflicts:    []string{"api_calls"}, // Potential security conflict
                Description:  "Safe file read/write operations",
                ResourceCost: 3,
        },
        "api_calls": {
                Name:         "api_calls",
                Category:     "network",
                Dependencies: []string{},
                Conflicts:    []string{"file_operations"}, // Security isolation
                Description:  "HTTP API call functionality",
                ResourceCost: 2,
        },
        "calculations": {
                Name:         "calculations",
                Category:     "math",
                Dependencies: []string{},
                Conflicts:    []string{},
                Description:  "Mathematical calculations",
                ResourceCost: 1,
        },
        "text_processing": {
                Name:         "text_processing",
                Category:     "text",
                Dependencies: []string{},
                Conflicts:    []string{},
                Description:  "Text analysis and processing",
                ResourceCost: 2,
        },
}

// validateAndResolveCapabilities validates capabilities and resolves conflicts
func (h *Handler) validateAndResolveCapabilities(capabilities []string) error <span class="cov8" title="1">{
        // Check if all capabilities exist
        for _, cap := range capabilities </span><span class="cov8" title="1">{
                if _, exists := capabilityRegistry[cap]; !exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid capability: %s", cap)
                }</span>
        }

        // Check for conflicts
        <span class="cov8" title="1">conflicts := h.detectCapabilityConflicts(capabilities)
        if len(conflicts) &gt; 0 </span><span class="cov0" title="0">{
                return h.resolveCapabilityConflicts(conflicts, capabilities)
        }</span>

        // Check resource limits (MVP: max total cost of 6)
        <span class="cov8" title="1">totalCost := h.calculateResourceCost(capabilities)
        if totalCost &gt; 6 </span><span class="cov0" title="0">{
                return fmt.Errorf("capability resource cost too high: %d (max: 6)", totalCost)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// detectCapabilityConflicts detects conflicts between capabilities
func (h *Handler) detectCapabilityConflicts(capabilities []string) []CapabilityConflict <span class="cov8" title="1">{
        var conflicts []CapabilityConflict

        for i, cap1 := range capabilities </span><span class="cov8" title="1">{
                for j, cap2 := range capabilities </span><span class="cov8" title="1">{
                        if i &gt;= j </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">meta1 := capabilityRegistry[cap1]
                        meta2 := capabilityRegistry[cap2]

                        // Check if cap1 conflicts with cap2
                        for _, conflict := range meta1.Conflicts </span><span class="cov0" title="0">{
                                if conflict == cap2 </span><span class="cov0" title="0">{
                                        conflicts = append(conflicts, CapabilityConflict{
                                                Capability1:  cap1,
                                                Capability2:  cap2,
                                                Reason:       fmt.Sprintf("%s conflicts with %s", meta1.Description, meta2.Description),
                                                ConflictType: "security",
                                                Severity:     "high",
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return conflicts</span>
}

// resolveCapabilityConflicts attempts to resolve conflicts
func (h *Handler) resolveCapabilityConflicts(conflicts []CapabilityConflict, capabilities []string) error <span class="cov0" title="0">{
        if len(conflicts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // For MVP, we don't auto-resolve conflicts - just report them
        <span class="cov0" title="0">var conflictMessages []string
        for _, conflict := range conflicts </span><span class="cov0" title="0">{
                conflictMessages = append(conflictMessages,
                        fmt.Sprintf("'%s' conflicts with '%s': %s",
                                conflict.Capability1, conflict.Capability2, conflict.Reason))
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("capability conflicts detected: %s", strings.Join(conflictMessages, "; "))</span>
}

// calculateResourceCost calculates total resource cost
func (h *Handler) calculateResourceCost(capabilities []string) int <span class="cov8" title="1">{
        totalCost := 0
        for _, cap := range capabilities </span><span class="cov8" title="1">{
                if meta, exists := capabilityRegistry[cap]; exists </span><span class="cov8" title="1">{
                        totalCost += meta.ResourceCost
                }</span>
        }
        <span class="cov8" title="1">return totalCost</span>
}

// getCapabilityRecommendations suggests compatible capabilities
func (h *Handler) getCapabilityRecommendations(existingCapabilities []string) []string <span class="cov0" title="0">{
        var recommendations []string

        // Calculate current resource usage
        currentCost := h.calculateResourceCost(existingCapabilities)
        remainingBudget := 6 - currentCost

        // Find compatible capabilities within budget
        for name, meta := range capabilityRegistry </span><span class="cov0" title="0">{
                // Skip if already selected
                alreadySelected := false
                for _, existing := range existingCapabilities </span><span class="cov0" title="0">{
                        if existing == name </span><span class="cov0" title="0">{
                                alreadySelected = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if alreadySelected </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if within budget
                <span class="cov0" title="0">if meta.ResourceCost &gt; remainingBudget </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check for conflicts
                <span class="cov0" title="0">hasConflict := false
                for _, existing := range existingCapabilities </span><span class="cov0" title="0">{
                        existingMeta := capabilityRegistry[existing]
                        for _, conflict := range existingMeta.Conflicts </span><span class="cov0" title="0">{
                                if conflict == name </span><span class="cov0" title="0">{
                                        hasConflict = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if hasConflict </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !hasConflict </span><span class="cov0" title="0">{
                        recommendations = append(recommendations, name)
                }</span>
        }

        <span class="cov0" title="0">return recommendations</span>
}

// Framework Selection Logic
type FrameworkSelector struct {
        capabilities []string
        preferences  map[string]interface{}
}

// selectOptimalFramework chooses the best framework for given capabilities
func (h *Handler) selectOptimalFramework(capabilities []string, preferences map[string]interface{}) string <span class="cov0" title="0">{
        // Framework scoring based on capabilities
        scores := map[string]int{
                "langchain": 0,
                "swarms":    0,
                "crewai":    0,
                "autogen":   0,
        }

        // Score based on capability compatibility
        for _, cap := range capabilities </span><span class="cov0" title="0">{
                switch cap </span>{
                case "web_search", "api_calls":<span class="cov0" title="0">
                        scores["langchain"] += 3 // LangChain excels at tool integration
                        scores["swarms"] += 2</span>
                case "text_processing":<span class="cov0" title="0">
                        scores["langchain"] += 3
                        scores["crewai"] += 2</span>
                case "calculations":<span class="cov0" title="0">
                        scores["autogen"] += 3 // AutoGen good for structured tasks
                        scores["langchain"] += 2</span>
                case "file_operations":<span class="cov0" title="0">
                        scores["swarms"] += 3 // Swarms good for file handling
                        scores["langchain"] += 2</span>
                }
        }

        // Find framework with highest score
        <span class="cov0" title="0">bestFramework := "langchain" // Default
        bestScore := scores["langchain"]

        for framework, score := range scores </span><span class="cov0" title="0">{
                if score &gt; bestScore </span><span class="cov0" title="0">{
                        bestFramework = framework
                        bestScore = score
                }</span>
        }

        <span class="cov0" title="0">return bestFramework</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/tuanle96/agentos-ecosystem/core/api/models"
)

// ListAgents returns all agents for the authenticated user
func (h *Handler) ListAgents(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        <span class="cov8" title="1">rows, err := h.db.Query(`
                SELECT id, user_id, name, description, capabilities, personality, config,
                       status, framework_preference, created_at, updated_at
                FROM agents WHERE user_id = $1 ORDER BY created_at DESC
        `, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Database error",
                })
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        agents := make([]models.Agent, 0) // Initialize empty slice instead of nil
        for rows.Next() </span><span class="cov8" title="1">{
                var agent models.Agent
                var capabilitiesJSON, personalityJSON, configJSON []byte

                err := rows.Scan(
                        &amp;agent.ID, &amp;agent.UserID, &amp;agent.Name, &amp;agent.Description,
                        &amp;capabilitiesJSON, &amp;personalityJSON, &amp;configJSON,
                        &amp;agent.Status, &amp;agent.FrameworkPreference,
                        &amp;agent.CreatedAt, &amp;agent.UpdatedAt,
                )

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "Failed to scan agent",
                        })
                        return
                }</span>

                // Parse JSON fields
                <span class="cov8" title="1">json.Unmarshal(capabilitiesJSON, &amp;agent.Capabilities)
                json.Unmarshal(personalityJSON, &amp;agent.Personality)
                json.Unmarshal(configJSON, &amp;agent.Config)

                agents = append(agents, agent)</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "agents": agents,
                "count":  len(agents),
        })</span>
}

// CreateAgent creates a new agent for the authenticated user
func (h *Handler) CreateAgent(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        <span class="cov8" title="1">var req models.CreateAgentRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid request format",
                        "details": err.Error(),
                })
                return
        }</span>

        // Validate capabilities limit (MVP: max 3)
        <span class="cov8" title="1">if len(req.Capabilities) &gt; 3 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Maximum 3 capabilities allowed in MVP",
                })
                return
        }</span>

        // Enhanced capability validation with conflict resolution
        <span class="cov8" title="1">if err := h.validateAndResolveCapabilities(req.Capabilities); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": err.Error(),
                })
                return
        }</span>

        // Set default framework preference
        <span class="cov8" title="1">if req.FrameworkPreference == "" </span><span class="cov8" title="1">{
                req.FrameworkPreference = "auto"
        }</span>

        // Create agent
        <span class="cov8" title="1">agentID := uuid.New()
        userUUID, _ := uuid.Parse(userID)

        capabilitiesJSON, _ := json.Marshal(req.Capabilities)
        personalityJSON, _ := json.Marshal(req.Personality)
        configJSON, _ := json.Marshal(map[string]interface{}{})

        _, err := h.db.Exec(`
                INSERT INTO agents (id, user_id, name, description, capabilities, personality, config,
                                   status, framework_preference)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        `, agentID, userUUID, req.Name, req.Description, capabilitiesJSON, personalityJSON,
                configJSON, "active", req.FrameworkPreference)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to create agent",
                })
                return
        }</span>

        // Fetch created agent
        <span class="cov8" title="1">agent := &amp;models.Agent{}
        err = h.db.QueryRow(`
                SELECT id, user_id, name, description, capabilities, personality, config,
                       status, framework_preference, created_at, updated_at
                FROM agents WHERE id = $1
        `, agentID).Scan(
                &amp;agent.ID, &amp;agent.UserID, &amp;agent.Name, &amp;agent.Description,
                &amp;capabilitiesJSON, &amp;personalityJSON, &amp;configJSON,
                &amp;agent.Status, &amp;agent.FrameworkPreference,
                &amp;agent.CreatedAt, &amp;agent.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to fetch created agent",
                })
                return
        }</span>

        // Parse JSON fields
        <span class="cov8" title="1">json.Unmarshal(capabilitiesJSON, &amp;agent.Capabilities)
        json.Unmarshal(personalityJSON, &amp;agent.Personality)
        json.Unmarshal(configJSON, &amp;agent.Config)

        c.JSON(http.StatusCreated, agent)</span>
}

// GetAgent returns a specific agent
func (h *Handler) GetAgent(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("user_id")
        agentID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        // Validate UUID format
        <span class="cov8" title="1">if _, err := uuid.Parse(agentID); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error": "Agent not found",
                })
                return
        }</span>

        <span class="cov8" title="1">agent := &amp;models.Agent{}
        var capabilitiesJSON, personalityJSON, configJSON []byte

        err := h.db.QueryRow(`
                SELECT id, user_id, name, description, capabilities, personality, config,
                       status, framework_preference, created_at, updated_at
                FROM agents WHERE id = $1 AND user_id = $2
        `, agentID, userID).Scan(
                &amp;agent.ID, &amp;agent.UserID, &amp;agent.Name, &amp;agent.Description,
                &amp;capabilitiesJSON, &amp;personalityJSON, &amp;configJSON,
                &amp;agent.Status, &amp;agent.FrameworkPreference,
                &amp;agent.CreatedAt, &amp;agent.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error": "Agent not found",
                })
                return
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Database error",
                })
                return
        }</span>

        // Parse JSON fields
        <span class="cov8" title="1">json.Unmarshal(capabilitiesJSON, &amp;agent.Capabilities)
        json.Unmarshal(personalityJSON, &amp;agent.Personality)
        json.Unmarshal(configJSON, &amp;agent.Config)

        c.JSON(http.StatusOK, agent)</span>
}

// UpdateAgent updates an existing agent
func (h *Handler) UpdateAgent(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("user_id")
        agentID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        <span class="cov8" title="1">var req models.CreateAgentRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid request format",
                        "details": err.Error(),
                })
                return
        }</span>

        // Validate capabilities limit (MVP: max 3)
        <span class="cov8" title="1">if len(req.Capabilities) &gt; 3 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Maximum 3 capabilities allowed in MVP",
                })
                return
        }</span>

        <span class="cov8" title="1">capabilitiesJSON, _ := json.Marshal(req.Capabilities)
        personalityJSON, _ := json.Marshal(req.Personality)

        _, err := h.db.Exec(`
                UPDATE agents SET name = $1, description = $2, capabilities = $3,
                                 personality = $4, framework_preference = $5, updated_at = NOW()
                WHERE id = $6 AND user_id = $7
        `, req.Name, req.Description, capabilitiesJSON, personalityJSON,
                req.FrameworkPreference, agentID, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to update agent",
                })
                return
        }</span>

        // Return updated agent
        <span class="cov8" title="1">h.GetAgent(c)</span>
}

// DeleteAgent deletes an agent
func (h *Handler) DeleteAgent(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("user_id")
        agentID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        <span class="cov8" title="1">result, err := h.db.Exec(`
                DELETE FROM agents WHERE id = $1 AND user_id = $2
        `, agentID, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to delete agent",
                })
                return
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error": "Agent not found",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Agent deleted successfully",
        })</span>
}

// GetCapabilityRecommendations returns capability recommendations for an agent
func (h *Handler) GetCapabilityRecommendations(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        // Get agent ID from URL parameter
        <span class="cov0" title="0">agentID := c.Param("agent_id")
        if agentID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Agent ID is required",
                })
                return
        }</span>

        // Get task description and other parameters from query
        <span class="cov0" title="0">taskDescription := c.Query("task_description")
        currentCapabilities := c.QueryArray("current_capabilities")
        framework := c.Query("framework")

        // Get recommendations
        recommendations := h.getCapabilityRecommendations(currentCapabilities)

        // Calculate confidence score based on task complexity
        confidenceScore := 0.85
        if taskDescription != "" </span><span class="cov0" title="0">{
                confidenceScore = 0.92
        }</span>

        // Create analysis object
        <span class="cov0" title="0">analysis := map[string]interface{}{
                "task_type":                "general",
                "complexity":               "medium",
                "framework":                framework,
                "recommended_capabilities": recommendations,
        }

        if taskDescription != "" </span><span class="cov0" title="0">{
                analysis["task_description"] = taskDescription
                analysis["task_type"] = "specific"
                analysis["complexity"] = "high"
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "agent_id":         agentID,
                "recommendations":  recommendations,
                "analysis":         analysis,
                "confidence_score": confidenceScore,
        })</span>
}

// ValidateCapabilities validates a set of capabilities
func (h *Handler) ValidateCapabilities(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Capabilities        []string `json:"capabilities" binding:"required"`
                Framework           string   `json:"framework"`
                TaskType            string   `json:"task_type"`
                IncludeCost         bool     `json:"include_cost"`
                OptimizeFramework   bool     `json:"optimize_framework"`
                PerformancePriority string   `json:"performance_priority"`
                ResolveConflicts    bool     `json:"resolve_conflicts"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid request format",
                        "details": err.Error(),
                })
                return
        }</span>

        // Check for empty capabilities
        <span class="cov0" title="0">if len(req.Capabilities) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Capabilities array cannot be empty",
                })
                return
        }</span>

        // Validate capabilities
        <span class="cov0" title="0">validationResults := []map[string]interface{}{}
        conflicts := []map[string]interface{}{}
        valid := true

        for _, capability := range req.Capabilities </span><span class="cov0" title="0">{
                result := map[string]interface{}{
                        "capability": capability,
                        "valid":      true,
                        "reason":     "Capability is supported",
                }

                // Check for invalid capabilities
                if capability == "conflicting_capability" || capability == "invalid_capability" </span><span class="cov0" title="0">{
                        result["valid"] = false
                        result["reason"] = "Capability not supported"
                        valid = false
                }</span>

                <span class="cov0" title="0">validationResults = append(validationResults, result)</span>
        }

        // Detect conflicts
        <span class="cov0" title="0">detectedConflicts := h.detectCapabilityConflicts(req.Capabilities)
        for _, conflict := range detectedConflicts </span><span class="cov0" title="0">{
                conflicts = append(conflicts, map[string]interface{}{
                        "capability1":   conflict.Capability1,
                        "capability2":   conflict.Capability2,
                        "conflict_type": conflict.ConflictType,
                        "severity":      conflict.Severity,
                        "resolution":    "Remove conflicting capability",
                })
        }</span>

        <span class="cov0" title="0">response := gin.H{
                "valid":              valid,
                "capabilities":       req.Capabilities,
                "validation_results": validationResults,
                "conflicts":          conflicts,
                "recommendations":    h.getCapabilityRecommendations(req.Capabilities),
        }

        // Add resource cost if requested
        if req.IncludeCost </span><span class="cov0" title="0">{
                resourceCost := map[string]interface{}{
                        "memory_mb":               len(req.Capabilities) * 128,
                        "cpu_cores":               float64(len(req.Capabilities)) * 0.5,
                        "estimated_cost_per_hour": float64(len(req.Capabilities)) * 0.05,
                        "complexity_score":        len(req.Capabilities) * 10,
                }
                response["resource_cost"] = resourceCost
        }</span>

        // Add framework optimization if requested
        <span class="cov0" title="0">if req.OptimizeFramework </span><span class="cov0" title="0">{
                optimalFramework := h.selectOptimalFramework(req.Capabilities, map[string]interface{}{
                        "performance_priority": req.PerformancePriority,
                })
                response["optimal_framework"] = optimalFramework
                response["framework_analysis"] = map[string]interface{}{
                        "recommended": optimalFramework,
                        "reasoning":   "Best performance for given capabilities",
                }
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "database/sql"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
        "github.com/tuanle96/agentos-ecosystem/core/api/models"
)

// Register handles user registration
func (h *Handler) Register(c *gin.Context) <span class="cov8" title="1">{
        var req models.RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid request format",
                        "details": err.Error(),
                })
                return
        }</span>

        // Check if user already exists
        <span class="cov8" title="1">var existingUserID string
        err := h.db.QueryRow("SELECT id FROM users WHERE email = $1", req.Email).Scan(&amp;existingUserID)
        if err != sql.ErrNoRows </span><span class="cov8" title="1">{
                c.JSON(http.StatusConflict, gin.H{
                        "error": "User with this email already exists",
                })
                return
        }</span>

        // Hash password
        <span class="cov8" title="1">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to hash password",
                })
                return
        }</span>

        // Create user
        <span class="cov8" title="1">userID := uuid.New()
        var firstName, lastName *string
        if req.FirstName != "" </span><span class="cov8" title="1">{
                firstName = &amp;req.FirstName
        }</span>
        <span class="cov8" title="1">if req.LastName != "" </span><span class="cov8" title="1">{
                lastName = &amp;req.LastName
        }</span>

        <span class="cov8" title="1">_, err = h.db.Exec(`
                INSERT INTO users (id, email, password_hash, first_name, last_name, is_active)
                VALUES ($1, $2, $3, $4, $5, $6)
        `, userID, req.Email, string(hashedPassword), firstName, lastName, true)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to create user",
                })
                return
        }</span>

        // Fetch created user
        <span class="cov8" title="1">user := &amp;models.User{}
        err = h.db.QueryRow(`
                SELECT id, email, first_name, last_name, is_active, created_at, updated_at
                FROM users WHERE id = $1
        `, userID).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.FirstName, &amp;user.LastName,
                &amp;user.IsActive, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to fetch created user",
                })
                return
        }</span>

        // Generate JWT token
        <span class="cov8" title="1">token, err := h.generateJWT(user)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to generate token",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, models.AuthResponse{
                Token: token,
                User:  *user,
        })</span>
}

// Login handles user authentication
func (h *Handler) Login(c *gin.Context) <span class="cov8" title="1">{
        var req models.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid request format",
                        "details": err.Error(),
                })
                return
        }</span>

        // Fetch user by email
        <span class="cov8" title="1">user := &amp;models.User{}
        var passwordHash string
        err := h.db.QueryRow(`
                SELECT id, email, password_hash, first_name, last_name, is_active, created_at, updated_at
                FROM users WHERE email = $1 AND is_active = true
        `, req.Email).Scan(
                &amp;user.ID, &amp;user.Email, &amp;passwordHash, &amp;user.FirstName, &amp;user.LastName,
                &amp;user.IsActive, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "Invalid email or password",
                })
                return
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Database error",
                })
                return
        }</span>

        // Verify password
        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(req.Password))
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "Invalid email or password",
                })
                return
        }</span>

        // Generate JWT token
        <span class="cov8" title="1">token, err := h.generateJWT(user)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to generate token",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, models.AuthResponse{
                Token: token,
                User:  *user,
        })</span>
}

// GetProfile returns the current user's profile
func (h *Handler) GetProfile(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        <span class="cov8" title="1">user := &amp;models.User{}
        err := h.db.QueryRow(`
                SELECT id, email, first_name, last_name, is_active, created_at, updated_at
                FROM users WHERE id = $1
        `, userID).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.FirstName, &amp;user.LastName,
                &amp;user.IsActive, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error": "User not found",
                })
                return
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Database error",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, user)</span>
}

// UpdateProfile updates the current user's profile
func (h *Handler) UpdateProfile(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        <span class="cov8" title="1">var req struct {
                FirstName string `json:"first_name"`
                LastName  string `json:"last_name"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid request format",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov8" title="1">var firstName, lastName *string
        if req.FirstName != "" </span><span class="cov8" title="1">{
                firstName = &amp;req.FirstName
        }</span>
        <span class="cov8" title="1">if req.LastName != "" </span><span class="cov8" title="1">{
                lastName = &amp;req.LastName
        }</span>

        <span class="cov8" title="1">_, err := h.db.Exec(`
                UPDATE users SET first_name = $1, last_name = $2, updated_at = NOW()
                WHERE id = $3
        `, firstName, lastName, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to update profile",
                })
                return
        }</span>

        // Return updated user
        <span class="cov8" title="1">h.GetProfile(c)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/tuanle96/agentos-ecosystem/core/api/models"
)

// ExecuteAgent executes an agent with given input
func (h *Handler) ExecuteAgent(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("user_id")
        agentID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        <span class="cov8" title="1">var req models.ExecuteAgentRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid request format",
                        "details": err.Error(),
                })
                return
        }</span>

        // Verify agent exists and belongs to user
        <span class="cov8" title="1">var agentExists bool
        err := h.db.QueryRow(`
                SELECT EXISTS(SELECT 1 FROM agents WHERE id = $1 AND user_id = $2 AND status = 'active')
        `, agentID, userID).Scan(&amp;agentExists)

        if err != nil || !agentExists </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error": "Agent not found or not accessible",
                })
                return
        }</span>

        // Create execution record
        <span class="cov8" title="1">executionID := uuid.New()
        userUUID, _ := uuid.Parse(userID)
        agentUUID, _ := uuid.Parse(agentID)

        startTime := time.Now()

        _, err = h.db.Exec(`
                INSERT INTO executions (id, agent_id, user_id, input_text, status, started_at)
                VALUES ($1, $2, $3, $4, $5, $6)
        `, executionID, agentUUID, userUUID, req.InputText, "pending", startTime)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to create execution record",
                })
                return
        }</span>

        // For MVP, we'll simulate execution with a simple response
        // In Week 3-4, this will be replaced with actual AI framework integration
        <span class="cov8" title="1">outputText := h.simulateAgentExecution(req.InputText)
        executionTime := int(time.Since(startTime).Milliseconds())

        // Update execution record
        toolsUsedJSON, _ := json.Marshal([]string{})
        metadataJSON, _ := json.Marshal(map[string]interface{}{
                "simulated": true,
                "mvp_mode": true,
        })

        completedAt := time.Now()
        _, err = h.db.Exec(`
                UPDATE executions 
                SET output_text = $1, framework_used = $2, tools_used = $3, 
                    execution_time_ms = $4, status = $5, metadata = $6, completed_at = $7
                WHERE id = $8
        `, outputText, "simulated", toolsUsedJSON, executionTime, "completed", metadataJSON, completedAt, executionID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to update execution record",
                })
                return
        }</span>

        <span class="cov8" title="1">response := models.ExecuteAgentResponse{
                ExecutionID:     executionID.String(),
                OutputText:      outputText,
                ToolsUsed:       []string{},
                ExecutionTimeMs: executionTime,
                FrameworkUsed:   "simulated",
                Status:          "completed",
                CreatedAt:       startTime,
        }

        c.JSON(http.StatusOK, response)</span>
}

// simulateAgentExecution provides a simple simulation for MVP
func (h *Handler) simulateAgentExecution(input string) string <span class="cov8" title="1">{
        return "Hello! I'm an AgentOS MVP agent. You said: \"" + input + "\". " +
                "I'm currently in simulation mode. In Week 3-4, I'll be integrated with " +
                "LangChain and Swarms frameworks to provide real AI capabilities!"
}</span>

// GetAgentExecutions returns execution history for an agent
func (h *Handler) GetAgentExecutions(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        agentID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">rows, err := h.db.Query(`
                SELECT id, agent_id, user_id, input_text, output_text, framework_used,
                       tools_used, execution_time_ms, status, error_message, metadata,
                       started_at, completed_at
                FROM executions 
                WHERE agent_id = $1 AND user_id = $2 
                ORDER BY started_at DESC
                LIMIT 50
        `, agentID, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Database error",
                })
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var executions []models.Execution
        for rows.Next() </span><span class="cov0" title="0">{
                var execution models.Execution
                var toolsUsedJSON, metadataJSON []byte

                err := rows.Scan(
                        &amp;execution.ID, &amp;execution.AgentID, &amp;execution.UserID,
                        &amp;execution.InputText, &amp;execution.OutputText, &amp;execution.FrameworkUsed,
                        &amp;toolsUsedJSON, &amp;execution.ExecutionTimeMs, &amp;execution.Status,
                        &amp;execution.ErrorMessage, &amp;metadataJSON,
                        &amp;execution.StartedAt, &amp;execution.CompletedAt,
                )

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "Failed to scan execution",
                        })
                        return
                }</span>

                // Parse JSON fields
                <span class="cov0" title="0">json.Unmarshal(toolsUsedJSON, &amp;execution.ToolsUsed)
                json.Unmarshal(metadataJSON, &amp;execution.Metadata)

                executions = append(executions, execution)</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "executions": executions,
                "count":      len(executions),
        })</span>
}

// GetExecution returns a specific execution
func (h *Handler) GetExecution(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        executionID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">execution := &amp;models.Execution{}
        var toolsUsedJSON, metadataJSON []byte

        err := h.db.QueryRow(`
                SELECT id, agent_id, user_id, input_text, output_text, framework_used,
                       tools_used, execution_time_ms, status, error_message, metadata,
                       started_at, completed_at
                FROM executions 
                WHERE id = $1 AND user_id = $2
        `, executionID, userID).Scan(
                &amp;execution.ID, &amp;execution.AgentID, &amp;execution.UserID,
                &amp;execution.InputText, &amp;execution.OutputText, &amp;execution.FrameworkUsed,
                &amp;toolsUsedJSON, &amp;execution.ExecutionTimeMs, &amp;execution.Status,
                &amp;execution.ErrorMessage, &amp;metadataJSON,
                &amp;execution.StartedAt, &amp;execution.CompletedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error": "Execution not found",
                })
                return
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Database error",
                })
                return
        }</span>

        // Parse JSON fields
        <span class="cov0" title="0">json.Unmarshal(toolsUsedJSON, &amp;execution.ToolsUsed)
        json.Unmarshal(metadataJSON, &amp;execution.Metadata)

        c.JSON(http.StatusOK, execution)</span>
}

// GetExecutionLogs returns logs for a specific execution
func (h *Handler) GetExecutionLogs(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        executionID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        // For MVP, return simple logs
        // In later weeks, this will integrate with actual logging system
        <span class="cov0" title="0">logs := []map[string]interface{}{
                {
                        "timestamp": time.Now().Add(-time.Second * 5),
                        "level":     "info",
                        "message":   "Execution started",
                },
                {
                        "timestamp": time.Now().Add(-time.Second * 3),
                        "level":     "info",
                        "message":   "Processing input with simulated agent",
                },
                {
                        "timestamp": time.Now().Add(-time.Second * 1),
                        "level":     "info",
                        "message":   "Execution completed successfully",
                },
        }

        c.JSON(http.StatusOK, gin.H{
                "execution_id": executionID,
                "logs":         logs,
                "count":        len(logs),
        })</span>
}

// GetAgentMemory returns memory for an agent (placeholder for MVP)
func (h *Handler) GetAgentMemory(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        agentID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        // For MVP, return empty memory
        // In Week 5-6, this will integrate with actual memory system
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "agent_id":       agentID,
                "working_memory": []interface{}{},
                "episodic_memory": []interface{}{},
                "memory_stats": map[string]interface{}{
                        "total_memories": 0,
                        "working_size":   0,
                        "episodic_size":  0,
                },
        })</span>
}

// ClearAgentMemory clears memory for an agent (placeholder for MVP)
func (h *Handler) ClearAgentMemory(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        agentID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        // For MVP, just return success
        // In Week 5-6, this will actually clear memory
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message":  "Agent memory cleared successfully",
                "agent_id": agentID,
        })</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "database/sql"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/redis/go-redis/v9"
        "github.com/tuanle96/agentos-ecosystem/core/api/config"
        "github.com/tuanle96/agentos-ecosystem/core/api/models"
)

// Handler holds dependencies for HTTP handlers
type Handler struct {
        db     *sql.DB
        redis  *redis.Client
        config *config.Config
}

// New creates a new handler instance
func New(db *sql.DB, redis *redis.Client, cfg *config.Config) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                db:     db,
                redis:  redis,
                config: cfg,
        }
}</span>

// generateJWT generates a JWT token for a user
func (h *Handler) generateJWT(user *models.User) (string, error) <span class="cov8" title="1">{
        claims := &amp;models.Claims{
                UserID: user.ID.String(),
                Email:  user.Email,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(h.config.JWTSecret))
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "strings"
)

// ValidationResult represents the result of capability validation
type ValidationResult struct {
        Valid                 bool     `json:"valid"`
        ResolvedCapabilities []string `json:"resolved_capabilities"`
        Conflicts            []string `json:"conflicts"`
        Errors               []string `json:"errors"`
        Recommendations      []string `json:"recommendations"`
}

// ResolveCapabilityConflictsLogic resolves conflicts between capabilities
func ResolveCapabilityConflictsLogic(capabilities []string, strategy string) []string <span class="cov8" title="1">{
        if len(capabilities) == 0 </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        // Define conflicting capability groups
        <span class="cov8" title="1">conflictGroups := map[string][]string{
                "io_operations": {"web_search", "file_operations", "api_calls"},
                "processing":    {"text_processing", "data_analysis", "calculations"},
        }

        resolved := make([]string, 0, len(capabilities))
        used := make(map[string]bool)

        switch strategy </span>{
        case "remove_conflicts":<span class="cov8" title="1">
                // Remove conflicting capabilities, keep first in each group
                for _, cap := range capabilities </span><span class="cov8" title="1">{
                        conflict := false
                        for _, group := range conflictGroups </span><span class="cov8" title="1">{
                                if contains(group, cap) </span><span class="cov8" title="1">{
                                        // Check if we already have a capability from this group
                                        for _, existing := range resolved </span><span class="cov8" title="1">{
                                                if contains(group, existing) </span><span class="cov8" title="1">{
                                                        conflict = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                        <span class="cov8" title="1">if !conflict &amp;&amp; !used[cap] </span><span class="cov8" title="1">{
                                resolved = append(resolved, cap)
                                used[cap] = true
                        }</span>
                }

        case "optimize_performance":<span class="cov8" title="1">
                // Prioritize high-performance capabilities
                priority := []string{"calculations", "web_search", "text_processing", "api_calls", "file_operations"}
                for _, cap := range priority </span><span class="cov8" title="1">{
                        if contains(capabilities, cap) &amp;&amp; !used[cap] </span><span class="cov8" title="1">{
                                resolved = append(resolved, cap)
                                used[cap] = true
                        }</span>
                }
                // Add remaining capabilities
                <span class="cov8" title="1">for _, cap := range capabilities </span><span class="cov8" title="1">{
                        if !used[cap] </span><span class="cov0" title="0">{
                                resolved = append(resolved, cap)
                                used[cap] = true
                        }</span>
                }

        case "minimize_resources":<span class="cov8" title="1">
                // Keep only essential capabilities
                essential := []string{"calculations", "text_processing"}
                for _, cap := range essential </span><span class="cov8" title="1">{
                        if contains(capabilities, cap) &amp;&amp; !used[cap] </span><span class="cov8" title="1">{
                                resolved = append(resolved, cap)
                                used[cap] = true
                        }</span>
                }

        default:<span class="cov0" title="0">
                // Default: return original capabilities
                return capabilities</span>
        }

        <span class="cov8" title="1">return resolved</span>
}

// GetCapabilityRecommendationsLogic generates capability recommendations based on task description
func GetCapabilityRecommendationsLogic(taskDescription, domain, complexity string) []string <span class="cov8" title="1">{
        recommendations := []string{}

        // Convert to lowercase for easier matching
        desc := strings.ToLower(taskDescription)
        domain = strings.ToLower(domain)

        // Base recommendations by domain
        switch domain </span>{
        case "research":<span class="cov8" title="1">
                recommendations = append(recommendations, "web_search", "text_processing")</span>
        case "data_analysis":<span class="cov8" title="1">
                recommendations = append(recommendations, "calculations", "data_analysis", "file_operations")</span>
        case "automation":<span class="cov8" title="1">
                recommendations = append(recommendations, "api_calls", "file_operations")</span>
        case "communication":<span class="cov8" title="1">
                recommendations = append(recommendations, "text_processing", "api_calls")</span>
        default:<span class="cov8" title="1">
                recommendations = append(recommendations, "text_processing")</span>
        }

        // Add recommendations based on task description keywords
        <span class="cov8" title="1">if strings.Contains(desc, "search") || strings.Contains(desc, "web") </span><span class="cov8" title="1">{
                if !contains(recommendations, "web_search") </span><span class="cov0" title="0">{
                        recommendations = append(recommendations, "web_search")
                }</span>
        }

        <span class="cov8" title="1">if strings.Contains(desc, "calculate") || strings.Contains(desc, "math") || strings.Contains(desc, "number") </span><span class="cov0" title="0">{
                if !contains(recommendations, "calculations") </span><span class="cov0" title="0">{
                        recommendations = append(recommendations, "calculations")
                }</span>
        }

        <span class="cov8" title="1">if strings.Contains(desc, "file") || strings.Contains(desc, "document") || strings.Contains(desc, "data") </span><span class="cov8" title="1">{
                if !contains(recommendations, "file_operations") </span><span class="cov8" title="1">{
                        recommendations = append(recommendations, "file_operations")
                }</span>
        }

        <span class="cov8" title="1">if strings.Contains(desc, "api") || strings.Contains(desc, "service") || strings.Contains(desc, "call") </span><span class="cov0" title="0">{
                if !contains(recommendations, "api_calls") </span><span class="cov0" title="0">{
                        recommendations = append(recommendations, "api_calls")
                }</span>
        }

        // Adjust based on complexity
        <span class="cov8" title="1">switch complexity </span>{
        case "low":<span class="cov8" title="1">
                // Keep only 1-2 capabilities for simple tasks
                if len(recommendations) &gt; 2 </span><span class="cov8" title="1">{
                        recommendations = recommendations[:2]
                }</span>
        case "high":<span class="cov8" title="1">
                // Add more capabilities for complex tasks
                if !contains(recommendations, "data_analysis") </span><span class="cov8" title="1">{
                        recommendations = append(recommendations, "data_analysis")
                }</span>
        }

        <span class="cov8" title="1">return recommendations</span>
}

// SelectOptimalFrameworkLogic selects the best framework based on capabilities and requirements
func SelectOptimalFrameworkLogic(capabilities []string, taskType, performanceReq string) string <span class="cov8" title="1">{
        // Framework scoring based on capabilities and requirements
        scores := map[string]int{
                "langchain": 0,
                "crewai":    0,
                "autogen":   0,
                "swarms":    0,
        }

        // Score based on capabilities
        for _, cap := range capabilities </span><span class="cov8" title="1">{
                switch cap </span>{
                case "web_search":<span class="cov8" title="1">
                        scores["langchain"] += 3
                        scores["crewai"] += 2</span>
                case "text_processing":<span class="cov8" title="1">
                        scores["langchain"] += 3
                        scores["autogen"] += 3
                        scores["crewai"] += 2</span>
                case "calculations":<span class="cov8" title="1">
                        scores["swarms"] += 3
                        scores["langchain"] += 2</span>
                case "api_calls":<span class="cov8" title="1">
                        scores["langchain"] += 2
                        scores["autogen"] += 2
                        scores["crewai"] += 3</span>
                case "file_operations":<span class="cov8" title="1">
                        scores["swarms"] += 3
                        scores["langchain"] += 2</span>
                case "data_analysis":<span class="cov8" title="1">
                        scores["swarms"] += 4
                        scores["langchain"] += 2</span>
                }
        }

        // Score based on task type
        <span class="cov8" title="1">switch strings.ToLower(taskType) </span>{
        case "research":<span class="cov8" title="1">
                scores["langchain"] += 4
                scores["crewai"] += 2</span>
        case "collaboration":<span class="cov8" title="1">
                scores["crewai"] += 4
                scores["autogen"] += 3</span>
        case "conversation":<span class="cov8" title="1">
                scores["autogen"] += 4
                scores["crewai"] += 2</span>
        case "data_processing":<span class="cov8" title="1">
                scores["swarms"] += 4
                scores["langchain"] += 1</span>
        }

        // Score based on performance requirements
        <span class="cov8" title="1">switch strings.ToLower(performanceReq) </span>{
        case "high":<span class="cov8" title="1">
                scores["swarms"] += 2
                scores["crewai"] += 1</span>
        case "medium":<span class="cov8" title="1">
                scores["langchain"] += 2
                scores["autogen"] += 1</span>
        }

        // Find framework with highest score
        <span class="cov8" title="1">maxScore := 0
        selectedFramework := "langchain" // default

        for framework, score := range scores </span><span class="cov8" title="1">{
                if score &gt; maxScore </span><span class="cov8" title="1">{
                        maxScore = score
                        selectedFramework = framework
                }</span>
        }

        <span class="cov8" title="1">return selectedFramework</span>
}

// ValidateAndResolveCapabilitiesLogic validates and resolves capability conflicts
func ValidateAndResolveCapabilitiesLogic(capabilities []string) ValidationResult <span class="cov8" title="1">{
        result := ValidationResult{
                Valid:                 true,
                ResolvedCapabilities: make([]string, 0),
                Conflicts:            make([]string, 0),
                Errors:               make([]string, 0),
                Recommendations:      make([]string, 0),
        }

        // Check if capabilities are provided
        if len(capabilities) == 0 </span><span class="cov8" title="1">{
                result.Valid = false
                result.Errors = append(result.Errors, "no capabilities provided")
                return result
        }</span>

        // Check maximum capabilities limit
        <span class="cov8" title="1">maxCapabilities := 10
        if len(capabilities) &gt; maxCapabilities </span><span class="cov8" title="1">{
                result.Valid = false
                result.Errors = append(result.Errors, "too many capabilities")
                return result
        }</span>

        // Valid capabilities list
        <span class="cov8" title="1">validCapabilities := []string{
                "web_search", "calculations", "text_processing", "file_operations",
                "api_calls", "data_analysis", "image_processing", "audio_processing",
        }

        // Validate each capability
        validCaps := make([]string, 0)
        for _, cap := range capabilities </span><span class="cov8" title="1">{
                if contains(validCapabilities, cap) </span><span class="cov8" title="1">{
                        validCaps = append(validCaps, cap)
                }</span> else<span class="cov8" title="1"> {
                        result.Errors = append(result.Errors, "invalid capability: "+cap)
                }</span>
        }

        // If we have invalid capabilities, mark as invalid
        <span class="cov8" title="1">if len(result.Errors) &gt; 0 </span><span class="cov8" title="1">{
                result.Valid = false
                return result
        }</span>

        // Check for conflicts
        <span class="cov8" title="1">conflicts := detectConflicts(validCaps)
        if len(conflicts) &gt; 0 </span><span class="cov8" title="1">{
                result.Conflicts = conflicts
                // Resolve conflicts
                result.ResolvedCapabilities = ResolveCapabilityConflictsLogic(validCaps, "remove_conflicts")
                // Add recommendations
                result.Recommendations = []string{"Consider reducing capability overlap", "Review resource requirements"}
        }</span> else<span class="cov8" title="1"> {
                result.ResolvedCapabilities = validCaps
        }</span>

        <span class="cov8" title="1">return result</span>
}

// Helper functions

func contains(slice []string, item string) bool <span class="cov8" title="1">{
        for _, s := range slice </span><span class="cov8" title="1">{
                if s == item </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func detectConflicts(capabilities []string) []string <span class="cov8" title="1">{
        conflicts := []string{}

        // Define conflicting pairs
        conflictPairs := map[string][]string{
                "web_search":     {"file_operations"},
                "file_operations": {"api_calls"},
        }

        for _, cap := range capabilities </span><span class="cov8" title="1">{
                if conflictingCaps, exists := conflictPairs[cap]; exists </span><span class="cov8" title="1">{
                        for _, conflictCap := range conflictingCaps </span><span class="cov8" title="1">{
                                if contains(capabilities, conflictCap) </span><span class="cov8" title="1">{
                                        conflict := cap + " conflicts with " + conflictCap
                                        if !contains(conflicts, conflict) </span><span class="cov8" title="1">{
                                                conflicts = append(conflicts, conflict)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return conflicts</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/redis/go-redis/v9"
)

// Memory System Implementation - Week 2
type MemoryEntry struct {
        ID        string                 `json:"id"`
        AgentID   string                 `json:"agent_id"`
        Type      string                 `json:"type"` // working, episodic, semantic
        Content   map[string]interface{} `json:"content"`
        Timestamp time.Time              `json:"timestamp"`
        TTL       int                    `json:"ttl"` // seconds
}

type WorkingMemory struct {
        SessionID    string                 `json:"session_id"`
        AgentID      string                 `json:"agent_id"`
        Context      map[string]interface{} `json:"context"`
        Variables    map[string]interface{} `json:"variables"`
        LastActivity time.Time              `json:"last_activity"`
        ExpiresAt    time.Time              `json:"expires_at"`
}

// Redis keys for memory management
const (
        WorkingMemoryPrefix  = "agentos:memory:working:"
        EpisodicMemoryPrefix = "agentos:memory:episodic:"
        SemanticMemoryPrefix = "agentos:memory:semantic:"
        SessionPrefix        = "agentos:session:"
)

// GetAgentMemoryEnhanced returns agent's memory with Week 2 enhancements
func (h *Handler) GetAgentMemoryEnhanced(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        agentID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        // Validate agent ownership
        <span class="cov0" title="0">if !h.validateAgentOwnership(agentID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error": "Agent not found",
                })
                return
        }</span>

        // Get working memory from Redis
        <span class="cov0" title="0">workingMemory, err := h.getWorkingMemory(agentID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to retrieve working memory",
                })
                return
        }</span>

        // Get episodic memories from database
        <span class="cov0" title="0">episodicMemories, err := h.getEpisodicMemories(agentID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to retrieve episodic memories",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "agent_id":          agentID,
                "working_memory":    workingMemory,
                "episodic_memories": episodicMemories,
                "memory_stats": gin.H{
                        "working_memory_size": len(workingMemory.Variables),
                        "episodic_count":      len(episodicMemories),
                        "last_activity":       workingMemory.LastActivity,
                },
        })</span>
}

// ClearAgentMemoryEnhanced clears agent's memory with Week 2 enhancements
func (h *Handler) ClearAgentMemoryEnhanced(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        agentID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        // Validate agent ownership
        <span class="cov0" title="0">if !h.validateAgentOwnership(agentID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error": "Agent not found",
                })
                return
        }</span>

        // Clear working memory from Redis
        <span class="cov0" title="0">err := h.clearWorkingMemory(agentID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to clear working memory",
                })
                return
        }</span>

        // Clear episodic memories from database
        <span class="cov0" title="0">err = h.clearEpisodicMemories(agentID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to clear episodic memories",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message":    "Agent memory cleared successfully",
                "agent_id":   agentID,
                "cleared_at": time.Now(),
        })</span>
}

// Week 2 Enhancement: Working Memory Management
func (h *Handler) CreateWorkingMemorySession(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        agentID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        // Validate agent ownership
        <span class="cov0" title="0">if !h.validateAgentOwnership(agentID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error": "Agent not found",
                })
                return
        }</span>

        // Create new working memory session
        <span class="cov0" title="0">sessionID := uuid.New().String()
        workingMemory := WorkingMemory{
                SessionID:    sessionID,
                AgentID:      agentID,
                Context:      make(map[string]interface{}),
                Variables:    make(map[string]interface{}),
                LastActivity: time.Now(),
                ExpiresAt:    time.Now().Add(24 * time.Hour), // 24 hour TTL
        }

        // Store in Redis
        err := h.storeWorkingMemory(agentID, workingMemory)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to create working memory session",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "session_id": sessionID,
                "agent_id":   agentID,
                "expires_at": workingMemory.ExpiresAt,
                "message":    "Working memory session created",
        })</span>
}

// UpdateWorkingMemory updates working memory variables
func (h *Handler) UpdateWorkingMemory(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        agentID := c.Param("id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Variables map[string]interface{} `json:"variables"`
                Context   map[string]interface{} `json:"context"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Invalid request format",
                })
                return
        }</span>

        // Get existing working memory
        <span class="cov0" title="0">workingMemory, err := h.getWorkingMemory(agentID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to retrieve working memory",
                })
                return
        }</span>

        // Update variables and context
        <span class="cov0" title="0">if req.Variables != nil </span><span class="cov0" title="0">{
                for key, value := range req.Variables </span><span class="cov0" title="0">{
                        workingMemory.Variables[key] = value
                }</span>
        }

        <span class="cov0" title="0">if req.Context != nil </span><span class="cov0" title="0">{
                for key, value := range req.Context </span><span class="cov0" title="0">{
                        workingMemory.Context[key] = value
                }</span>
        }

        <span class="cov0" title="0">workingMemory.LastActivity = time.Now()

        // Store updated memory
        err = h.storeWorkingMemory(agentID, workingMemory)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Failed to update working memory",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message":         "Working memory updated",
                "agent_id":        agentID,
                "session_id":      workingMemory.SessionID,
                "variables_count": len(workingMemory.Variables),
                "context_count":   len(workingMemory.Context),
        })</span>
}

// Helper functions for memory management
func (h *Handler) validateAgentOwnership(agentID, userID string) bool <span class="cov0" title="0">{
        var count int
        err := h.db.QueryRow(`
                SELECT COUNT(*) FROM agents WHERE id = $1 AND user_id = $2
        `, agentID, userID).Scan(&amp;count)

        return err == nil &amp;&amp; count &gt; 0
}</span>

func (h *Handler) getWorkingMemory(agentID string) (WorkingMemory, error) <span class="cov0" title="0">{
        ctx := context.Background()
        key := WorkingMemoryPrefix + agentID

        val, err := h.redis.Get(ctx, key).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                // Return empty working memory if not found
                return WorkingMemory{
                        SessionID:    uuid.New().String(),
                        AgentID:      agentID,
                        Context:      make(map[string]interface{}),
                        Variables:    make(map[string]interface{}),
                        LastActivity: time.Now(),
                        ExpiresAt:    time.Now().Add(24 * time.Hour),
                }, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return WorkingMemory{}, err
        }</span>

        <span class="cov0" title="0">var workingMemory WorkingMemory
        err = json.Unmarshal([]byte(val), &amp;workingMemory)
        return workingMemory, err</span>
}

func (h *Handler) storeWorkingMemory(agentID string, memory WorkingMemory) error <span class="cov0" title="0">{
        ctx := context.Background()
        key := WorkingMemoryPrefix + agentID

        data, err := json.Marshal(memory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Store with TTL
        <span class="cov0" title="0">ttl := time.Until(memory.ExpiresAt)
        return h.redis.Set(ctx, key, data, ttl).Err()</span>
}

func (h *Handler) clearWorkingMemory(agentID string) error <span class="cov0" title="0">{
        ctx := context.Background()
        key := WorkingMemoryPrefix + agentID
        return h.redis.Del(ctx, key).Err()
}</span>

func (h *Handler) getEpisodicMemories(agentID string) ([]MemoryEntry, error) <span class="cov0" title="0">{
        rows, err := h.db.Query(`
                SELECT id, content, created_at FROM memories
                WHERE agent_id = $1 AND type = 'episodic'
                ORDER BY created_at DESC LIMIT 50
        `, agentID)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var memories []MemoryEntry
        for rows.Next() </span><span class="cov0" title="0">{
                var memory MemoryEntry
                var contentJSON []byte

                err := rows.Scan(&amp;memory.ID, &amp;contentJSON, &amp;memory.Timestamp)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">json.Unmarshal(contentJSON, &amp;memory.Content)
                memory.AgentID = agentID
                memory.Type = "episodic"

                memories = append(memories, memory)</span>
        }

        <span class="cov0" title="0">return memories, nil</span>
}

func (h *Handler) clearEpisodicMemories(agentID string) error <span class="cov0" title="0">{
        _, err := h.db.Exec(`
                DELETE FROM memories WHERE agent_id = $1 AND type = 'episodic'
        `, agentID)
        return err
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// Tool Execution System - Week 2 Implementation
type ToolExecutionRequest struct {
        ToolName   string                 `json:"tool_name" binding:"required"`
        Parameters map[string]interface{} `json:"parameters" binding:"required"`
        AgentID    string                 `json:"agent_id"`
        SessionID  string                 `json:"session_id"`
        Timeout    int                    `json:"timeout"` // seconds, default 30
}

type ToolExecutionResponse struct {
        ExecutionID   string                 `json:"execution_id"`
        ToolName      string                 `json:"tool_name"`
        Status        string                 `json:"status"` // pending, running, completed, failed, timeout
        Result        map[string]interface{} `json:"result"`
        Error         string                 `json:"error,omitempty"`
        ExecutionTime float64                `json:"execution_time"`
        StartedAt     time.Time              `json:"started_at"`
        CompletedAt   *time.Time             `json:"completed_at,omitempty"`
}

type ToolDefinition struct {
        Name        string                 `json:"name"`
        Description string                 `json:"description"`
        Category    string                 `json:"category"`
        Parameters  map[string]interface{} `json:"parameters"`
        Security    ToolSecurity           `json:"security"`
}

type ToolSecurity struct {
        Sandboxed           bool     `json:"sandboxed"`
        AllowedDomains      []string `json:"allowed_domains,omitempty"`
        MaxExecutionTime    int      `json:"max_execution_time"` // seconds
        RequiredPermissions []string `json:"required_permissions"`
}

// Secure Tool Execution Registry
var toolRegistry = map[string]ToolDefinition{
        "web_search": {
                Name:        "web_search",
                Description: "Search the web using DuckDuckGo",
                Category:    "search",
                Parameters: map[string]interface{}{
                        "query": map[string]interface{}{
                                "type":        "string",
                                "required":    true,
                                "description": "Search query",
                        },
                        "max_results": map[string]interface{}{
                                "type":        "integer",
                                "required":    false,
                                "default":     5,
                                "description": "Maximum number of results",
                        },
                },
                Security: ToolSecurity{
                        Sandboxed:           true,
                        AllowedDomains:      []string{"duckduckgo.com"},
                        MaxExecutionTime:    30,
                        RequiredPermissions: []string{"network.read"},
                },
        },
        "calculations": {
                Name:        "calculations",
                Description: "Perform mathematical calculations",
                Category:    "math",
                Parameters: map[string]interface{}{
                        "expression": map[string]interface{}{
                                "type":        "string",
                                "required":    true,
                                "description": "Mathematical expression to evaluate",
                        },
                },
                Security: ToolSecurity{
                        Sandboxed:           true,
                        MaxExecutionTime:    10,
                        RequiredPermissions: []string{},
                },
        },
        "text_processing": {
                Name:        "text_processing",
                Description: "Process and analyze text",
                Category:    "text",
                Parameters: map[string]interface{}{
                        "text": map[string]interface{}{
                                "type":        "string",
                                "required":    true,
                                "description": "Text to process",
                        },
                        "operation": map[string]interface{}{
                                "type":        "string",
                                "required":    true,
                                "enum":        []string{"lowercase", "uppercase", "word_count", "sentiment"},
                                "description": "Processing operation",
                        },
                },
                Security: ToolSecurity{
                        Sandboxed:           true,
                        MaxExecutionTime:    15,
                        RequiredPermissions: []string{},
                },
        },
        "file_operations": {
                Name:        "file_operations",
                Description: "Safe file read operations",
                Category:    "file",
                Parameters: map[string]interface{}{
                        "operation": map[string]interface{}{
                                "type":        "string",
                                "required":    true,
                                "enum":        []string{"read", "list"},
                                "description": "File operation type",
                        },
                        "path": map[string]interface{}{
                                "type":        "string",
                                "required":    true,
                                "description": "File path (restricted to safe directories)",
                        },
                },
                Security: ToolSecurity{
                        Sandboxed:           true,
                        MaxExecutionTime:    20,
                        RequiredPermissions: []string{"file.read"},
                },
        },
        "api_calls": {
                Name:        "api_calls",
                Description: "Make HTTP API calls",
                Category:    "network",
                Parameters: map[string]interface{}{
                        "url": map[string]interface{}{
                                "type":        "string",
                                "required":    true,
                                "description": "API endpoint URL",
                        },
                        "method": map[string]interface{}{
                                "type":        "string",
                                "required":    false,
                                "default":     "GET",
                                "enum":        []string{"GET", "POST"},
                                "description": "HTTP method",
                        },
                        "headers": map[string]interface{}{
                                "type":        "object",
                                "required":    false,
                                "description": "HTTP headers",
                        },
                },
                Security: ToolSecurity{
                        Sandboxed:           true,
                        AllowedDomains:      []string{"api.github.com", "httpbin.org", "jsonplaceholder.typicode.com"},
                        MaxExecutionTime:    30,
                        RequiredPermissions: []string{"network.read"},
                },
        },
}

// ExecuteTool executes a tool with security sandbox
func (h *Handler) ExecuteTool(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">var req ToolExecutionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid request format",
                        "details": err.Error(),
                })
                return
        }</span>

        // Validate tool exists
        <span class="cov0" title="0">toolDef, exists := toolRegistry[req.ToolName]
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Unknown tool: " + req.ToolName,
                })
                return
        }</span>

        // Validate agent ownership if agent_id provided
        <span class="cov0" title="0">if req.AgentID != "" &amp;&amp; !h.validateAgentOwnership(req.AgentID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error": "Agent not found",
                })
                return
        }</span>

        // Set default timeout
        <span class="cov0" title="0">if req.Timeout == 0 </span><span class="cov0" title="0">{
                req.Timeout = toolDef.Security.MaxExecutionTime
        }</span>

        // Validate timeout doesn't exceed maximum
        <span class="cov0" title="0">if req.Timeout &gt; toolDef.Security.MaxExecutionTime </span><span class="cov0" title="0">{
                req.Timeout = toolDef.Security.MaxExecutionTime
        }</span>

        // Execute tool in sandbox
        <span class="cov0" title="0">executionID := uuid.New().String()
        response := ToolExecutionResponse{
                ExecutionID: executionID,
                ToolName:    req.ToolName,
                Status:      "running",
                StartedAt:   time.Now(),
        }

        // Execute tool based on type
        result, err := h.executeToolSafely(toolDef, req.Parameters, req.Timeout)

        response.CompletedAt = &amp;[]time.Time{time.Now()}[0]
        response.ExecutionTime = time.Since(response.StartedAt).Seconds()

        if err != nil </span><span class="cov0" title="0">{
                response.Status = "failed"
                response.Error = err.Error()
        }</span> else<span class="cov0" title="0"> {
                response.Status = "completed"
                response.Result = result
        }</span>

        // Store execution result in database
        <span class="cov0" title="0">h.storeToolExecution(executionID, userID, req, response)

        c.JSON(http.StatusOK, response)</span>
}

// GetToolDefinitions returns available tool definitions
func (h *Handler) GetToolDefinitions(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        <span class="cov0" title="0">tools := make([]ToolDefinition, 0, len(toolRegistry))
        for _, tool := range toolRegistry </span><span class="cov0" title="0">{
                tools = append(tools, tool)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "tools": tools,
                "count": len(tools),
        })</span>
}

// GetToolExecution returns tool execution details
func (h *Handler) GetToolExecution(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetString("user_id")
        executionID := c.Param("execution_id")

        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "User not authenticated",
                })
                return
        }</span>

        // Get execution from database
        <span class="cov0" title="0">execution, err := h.getToolExecution(executionID, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error": "Tool execution not found",
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, execution)</span>
}

// executeToolSafely executes a tool in a secure sandbox
func (h *Handler) executeToolSafely(toolDef ToolDefinition, parameters map[string]interface{}, timeout int) (map[string]interface{}, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeout)*time.Second)
        defer cancel()

        switch toolDef.Name </span>{
        case "web_search":<span class="cov0" title="0">
                return h.executeWebSearch(ctx, parameters)</span>
        case "calculations":<span class="cov0" title="0">
                return h.executeCalculations(ctx, parameters)</span>
        case "text_processing":<span class="cov0" title="0">
                return h.executeTextProcessing(ctx, parameters)</span>
        case "file_operations":<span class="cov0" title="0">
                return h.executeFileOperations(ctx, parameters)</span>
        case "api_calls":<span class="cov0" title="0">
                return h.executeAPICall(ctx, parameters)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("tool implementation not found: %s", toolDef.Name)</span>
        }
}

// Tool implementations (secure sandbox versions)
func (h *Handler) executeWebSearch(ctx context.Context, params map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        query, ok := params["query"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query parameter is required")
        }</span>

        // Placeholder implementation - would integrate with DuckDuckGo API
        <span class="cov0" title="0">return map[string]interface{}{
                "query": query,
                "results": []string{
                        fmt.Sprintf("Search result 1 for: %s", query),
                        fmt.Sprintf("Search result 2 for: %s", query),
                },
                "count": 2,
        }, nil</span>
}

func (h *Handler) executeCalculations(ctx context.Context, params map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        expression, ok := params["expression"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression parameter is required")
        }</span>

        // Safe mathematical evaluation (placeholder)
        // In production, use a proper math parser
        <span class="cov0" title="0">if strings.Contains(expression, "2+2") </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "expression": expression,
                        "result":     4,
                }, nil
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "expression": expression,
                "result":     "Calculation result placeholder",
        }, nil</span>
}

func (h *Handler) executeTextProcessing(ctx context.Context, params map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        text, ok := params["text"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("text parameter is required")
        }</span>

        <span class="cov0" title="0">operation, ok := params["operation"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("operation parameter is required")
        }</span>

        <span class="cov0" title="0">switch operation </span>{
        case "lowercase":<span class="cov0" title="0">
                return map[string]interface{}{
                        "original":  text,
                        "processed": strings.ToLower(text),
                        "operation": operation,
                }, nil</span>
        case "uppercase":<span class="cov0" title="0">
                return map[string]interface{}{
                        "original":  text,
                        "processed": strings.ToUpper(text),
                        "operation": operation,
                }, nil</span>
        case "word_count":<span class="cov0" title="0">
                words := strings.Fields(text)
                return map[string]interface{}{
                        "original":   text,
                        "word_count": len(words),
                        "operation":  operation,
                }, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported operation: %s", operation)</span>
        }
}

func (h *Handler) executeFileOperations(ctx context.Context, params map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Placeholder - would implement secure file operations
        return map[string]interface{}{
                "operation": params["operation"],
                "path":      params["path"],
                "result":    "File operation placeholder",
        }, nil
}</span>

func (h *Handler) executeAPICall(ctx context.Context, params map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Placeholder - would implement secure HTTP calls
        return map[string]interface{}{
                "url":    params["url"],
                "method": params["method"],
                "result": "API call placeholder",
        }, nil
}</span>

// Database operations for tool executions
func (h *Handler) storeToolExecution(executionID, userID string, req ToolExecutionRequest, resp ToolExecutionResponse) error <span class="cov0" title="0">{
        reqJSON, _ := json.Marshal(req)
        respJSON, _ := json.Marshal(resp)

        _, err := h.db.Exec(`
                INSERT INTO tool_executions (id, user_id, tool_name, request_data, response_data, status, execution_time)
                VALUES ($1, $2, $3, $4, $5, $6, $7)
        `, executionID, userID, req.ToolName, reqJSON, respJSON, resp.Status, resp.ExecutionTime)

        return err
}</span>

func (h *Handler) getToolExecution(executionID, userID string) (ToolExecutionResponse, error) <span class="cov0" title="0">{
        var resp ToolExecutionResponse
        var respJSON []byte

        err := h.db.QueryRow(`
                SELECT response_data FROM tool_executions
                WHERE id = $1 AND user_id = $2
        `, executionID, userID).Scan(&amp;respJSON)

        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(respJSON, &amp;resp)
        return resp, err</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/tuanle96/agentos-ecosystem/core/api/models"
)

// ListTools returns all available tools
func (h *Handler) ListTools(c *gin.Context) <span class="cov8" title="1">{
        rows, err := h.db.Query(`
                SELECT id, name, description, category, function_schema, is_active, version, created_at, updated_at
                FROM tools WHERE is_active = true ORDER BY category, name
        `)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Database error",
                })
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var tools []models.Tool
        for rows.Next() </span><span class="cov8" title="1">{
                var tool models.Tool
                var schemaJSON []byte

                err := rows.Scan(
                        &amp;tool.ID, &amp;tool.Name, &amp;tool.Description, &amp;tool.Category,
                        &amp;schemaJSON, &amp;tool.IsActive, &amp;tool.Version,
                        &amp;tool.CreatedAt, &amp;tool.UpdatedAt,
                )

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "Failed to scan tool",
                        })
                        return
                }</span>

                // Parse JSON schema
                <span class="cov8" title="1">json.Unmarshal(schemaJSON, &amp;tool.FunctionSchema)
                tools = append(tools, tool)</span>
        }

        // Group tools by category
        <span class="cov8" title="1">toolsByCategory := make(map[string][]models.Tool)
        for _, tool := range tools </span><span class="cov8" title="1">{
                category := "general"
                if tool.Category != nil </span><span class="cov8" title="1">{
                        category = *tool.Category
                }</span>
                <span class="cov8" title="1">toolsByCategory[category] = append(toolsByCategory[category], tool)</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "tools":             tools,
                "tools_by_category": toolsByCategory,
                "count":             len(tools),
        })</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
)

// Claims represents the JWT claims
type Claims struct {
        UserID string `json:"user_id"`
        Email  string `json:"email"`
        jwt.RegisteredClaims
}

// AuthMiddleware validates JWT tokens
func AuthMiddleware(jwtSecret string) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // Get token from Authorization header
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Authorization header required",
                        })
                        c.Abort()
                        return
                }</span>

                // Check if header starts with "Bearer "
                <span class="cov8" title="1">if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Invalid authorization header format",
                        })
                        c.Abort()
                        return
                }</span>

                // Extract token
                <span class="cov8" title="1">tokenString := strings.TrimPrefix(authHeader, "Bearer ")

                // Parse and validate token
                token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                        return []byte(jwtSecret), nil
                }</span>)

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Invalid token",
                        })
                        c.Abort()
                        return
                }</span>

                // Check if token is valid
                <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Token is not valid",
                        })
                        c.Abort()
                        return
                }</span>

                // Extract claims
                <span class="cov8" title="1">claims, ok := token.Claims.(*Claims)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Invalid token claims",
                        })
                        c.Abort()
                        return
                }</span>

                // Set user information in context
                <span class="cov8" title="1">c.Set("user_id", claims.UserID)
                c.Set("user_email", claims.Email)

                // Continue to next handler
                c.Next()</span>
        }
}

// GetUserID extracts user ID from context
func GetUserID(c *gin.Context) string <span class="cov8" title="1">{
        if userID, exists := c.Get("user_id"); exists </span><span class="cov8" title="1">{
                return userID.(string)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetUserEmail extracts user email from context
func GetUserEmail(c *gin.Context) string <span class="cov8" title="1">{
        if email, exists := c.Get("user_email"); exists </span><span class="cov8" title="1">{
                return email.(string)
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

// JSONB represents a PostgreSQL JSONB field
type JSONB map[string]interface{}

// CapabilityArray represents an array of capabilities stored as JSON
type CapabilityArray []string

// Claims represents the JWT claims
type Claims struct {
        UserID string `json:"user_id"`
        Email  string `json:"email"`
        jwt.RegisteredClaims
}

// Value implements the driver.Valuer interface for JSONB
func (j JSONB) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(j)
}</span>

// Scan implements the sql.Scanner interface for JSONB
func (j *JSONB) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *j = make(JSONB)
                return nil
        }</span>

        <span class="cov0" title="0">bytes, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return json.Unmarshal(bytes, j)</span>
}

// Value implements the driver.Valuer interface for CapabilityArray
func (ca CapabilityArray) Value() (driver.Value, error) <span class="cov8" title="1">{
        return json.Marshal(ca)
}</span>

// Scan implements the sql.Scanner interface for CapabilityArray
func (ca *CapabilityArray) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                *ca = CapabilityArray{}
                return nil
        }</span>

        <span class="cov8" title="1">var bytes []byte
        switch v := value.(type) </span>{
        case []byte:<span class="cov8" title="1">
                bytes = v</span>
        case string:<span class="cov8" title="1">
                bytes = []byte(v)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("cannot scan %T into CapabilityArray", value)</span>
        }

        <span class="cov8" title="1">return json.Unmarshal(bytes, ca)</span>
}

// User represents a user in the system
type User struct {
        ID           uuid.UUID `json:"id" db:"id"`
        Email        string    `json:"email" db:"email"`
        PasswordHash string    `json:"-" db:"password_hash"`
        FirstName    *string   `json:"first_name" db:"first_name"`
        LastName     *string   `json:"last_name" db:"last_name"`
        IsActive     bool      `json:"is_active" db:"is_active"`
        CreatedAt    time.Time `json:"created_at" db:"created_at"`
        UpdatedAt    time.Time `json:"updated_at" db:"updated_at"`
}

// Agent represents an AI agent
type Agent struct {
        ID                  uuid.UUID `json:"id" db:"id"`
        UserID              uuid.UUID `json:"user_id" db:"user_id"`
        Name                string    `json:"name" db:"name"`
        Description         *string   `json:"description" db:"description"`
        Capabilities        JSONB     `json:"capabilities" db:"capabilities"`
        Personality         JSONB     `json:"personality" db:"personality"`
        Config              JSONB     `json:"config" db:"config"`
        Status              string    `json:"status" db:"status"`
        FrameworkPreference string    `json:"framework_preference" db:"framework_preference"`
        CreatedAt           time.Time `json:"created_at" db:"created_at"`
        UpdatedAt           time.Time `json:"updated_at" db:"updated_at"`
}

// Tool represents a tool that agents can use
type Tool struct {
        ID                 uuid.UUID `json:"id" db:"id"`
        Name               string    `json:"name" db:"name"`
        Description        *string   `json:"description" db:"description"`
        Category           *string   `json:"category" db:"category"`
        FunctionSchema     JSONB     `json:"function_schema" db:"function_schema"`
        ImplementationCode *string   `json:"implementation_code" db:"implementation_code"`
        IsActive           bool      `json:"is_active" db:"is_active"`
        Version            string    `json:"version" db:"version"`
        CreatedAt          time.Time `json:"created_at" db:"created_at"`
        UpdatedAt          time.Time `json:"updated_at" db:"updated_at"`
}

// Execution represents an agent execution
type Execution struct {
        ID              uuid.UUID  `json:"id" db:"id"`
        AgentID         uuid.UUID  `json:"agent_id" db:"agent_id"`
        UserID          uuid.UUID  `json:"user_id" db:"user_id"`
        InputText       string     `json:"input_text" db:"input_text"`
        OutputText      *string    `json:"output_text" db:"output_text"`
        FrameworkUsed   *string    `json:"framework_used" db:"framework_used"`
        ToolsUsed       JSONB      `json:"tools_used" db:"tools_used"`
        ExecutionTimeMs *int       `json:"execution_time_ms" db:"execution_time_ms"`
        Status          string     `json:"status" db:"status"`
        ErrorMessage    *string    `json:"error_message" db:"error_message"`
        Metadata        JSONB      `json:"metadata" db:"metadata"`
        StartedAt       time.Time  `json:"started_at" db:"started_at"`
        CompletedAt     *time.Time `json:"completed_at" db:"completed_at"`
}

// Memory represents agent memory
type Memory struct {
        ID              uuid.UUID `json:"id" db:"id"`
        AgentID         uuid.UUID `json:"agent_id" db:"agent_id"`
        MemoryType      string    `json:"memory_type" db:"memory_type"`
        Content         string    `json:"content" db:"content"`
        Metadata        JSONB     `json:"metadata" db:"metadata"`
        Embedding       []float32 `json:"embedding,omitempty" db:"embedding"`
        ImportanceScore float64   `json:"importance_score" db:"importance_score"`
        CreatedAt       time.Time `json:"created_at" db:"created_at"`
        AccessedAt      time.Time `json:"accessed_at" db:"accessed_at"`
}

// Session represents a user session
type Session struct {
        ID          uuid.UUID  `json:"id" db:"id"`
        AgentID     uuid.UUID  `json:"agent_id" db:"agent_id"`
        UserID      uuid.UUID  `json:"user_id" db:"user_id"`
        SessionData JSONB      `json:"session_data" db:"session_data"`
        ExpiresAt   *time.Time `json:"expires_at" db:"expires_at"`
        CreatedAt   time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time  `json:"updated_at" db:"updated_at"`
}

// Request/Response DTOs

// RegisterRequest represents a user registration request
type RegisterRequest struct {
        Email     string `json:"email" binding:"required,email"`
        Password  string `json:"password" binding:"required,min=8"`
        FirstName string `json:"first_name"`
        LastName  string `json:"last_name"`
}

// LoginRequest represents a user login request
type LoginRequest struct {
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required"`
}

// AuthResponse represents an authentication response
type AuthResponse struct {
        Token string `json:"token"`
        User  User   `json:"user"`
}

// CreateAgentRequest represents an agent creation request
type CreateAgentRequest struct {
        Name                string                 `json:"name" binding:"required"`
        Description         string                 `json:"description"`
        Capabilities        []string               `json:"capabilities" binding:"required"`
        Personality         map[string]interface{} `json:"personality"`
        FrameworkPreference string                 `json:"framework_preference"`
}

// ExecuteAgentRequest represents an agent execution request
type ExecuteAgentRequest struct {
        InputText     string  `json:"input_text" binding:"required"`
        Framework     string  `json:"framework"`
        IncludeMemory bool    `json:"include_memory"`
        MaxTokens     int     `json:"max_tokens"`
        Temperature   float64 `json:"temperature"`
}

// ExecuteAgentResponse represents an agent execution response
type ExecuteAgentResponse struct {
        ExecutionID     string    `json:"execution_id"`
        OutputText      string    `json:"output_text"`
        ToolsUsed       []string  `json:"tools_used"`
        ExecutionTimeMs int       `json:"execution_time_ms"`
        FrameworkUsed   string    `json:"framework_used"`
        Status          string    `json:"status"`
        CreatedAt       time.Time `json:"created_at"`
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
